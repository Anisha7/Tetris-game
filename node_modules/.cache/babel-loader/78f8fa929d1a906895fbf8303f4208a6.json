{"ast":null,"code":"// get a random number between min and max\nexport var random = function random(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}; // Returns the default grid\n\nexport var gridDefault = function gridDefault() {\n  var rows = 18;\n  var cols = 10;\n  var array = []; // array of 18 arrays of 10 zeros\n\n  for (var row = 0; row < rows; row++) {\n    array.push([]);\n\n    for (var col = 0; col < cols; col++) {\n      array[row].push(0);\n    }\n  }\n\n  return array;\n}; // Define block shapes and their rotations as arrays.\n\nexport var shapes = [// none\n[[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]], // I\n[[[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]], // T\n[[[0, 0, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]], // L\n[[[0, 0, 0, 0], [1, 1, 1, 0], [1, 0, 0, 0], [0, 0, 0, 0]], [[1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]], [[0, 0, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]], // J\n[[[1, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 1, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [0, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0]]], // Z\n[[[0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]], [[0, 0, 1, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]], // S\n[[[0, 0, 0, 0], [0, 1, 1, 0], [1, 1, 0, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0]]], // O\n[[[0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]]; // Return the index of a random shape from 1 to the number of items in `shapes`\n// We don't want the first item, which is an empty shape\n\nexport var randomShape = function randomShape() {\n  return random(1, shapes.length - 1);\n}; // Return the default state for the game\n\nexport var defaultState = function defaultState() {\n  return {\n    // Create an empty grid\n    grid: gridDefault(),\n    // Get a new random shape\n    shape: randomShape(),\n    // set rotation of the shape to 0\n    rotation: 0,\n    // set the 'x' position of the shape to 5 and y to -4, which puts the shape in the center of the grid, above the top\n    x: 5,\n    y: -4,\n    // set the index of the next shape to a new random shape\n    nextShape: randomShape(),\n    // Tell the game that it's currently running\n    isRunning: true,\n    // Set the score to 0\n    score: 0,\n    // Set the default speed\n    speed: 1000,\n    // Game isn't over yet\n    gameOver: false\n  };\n}; // Returns the next rotation for a shape\n// rotation can't exceed the last index of the the rotations for the given shape.\n\nexport var nextRotation = function nextRotation(shape, rotation) {\n  return (rotation + 1) % shapes[shape].length;\n};\nexport var canMoveTo = function canMoveTo(shape, grid, x, y, rotation) {\n  var currentShape = shapes[shape][rotation]; // Loop through all rows and cols of the **shape**\n\n  for (var row = 0; row < currentShape.length; row++) {\n    for (var col = 0; col < currentShape[row].length; col++) {\n      // Look for a 1 here\n      if (currentShape[row][col] !== 0) {\n        // x offset on grid\n        var proposedX = col + x; // y offset on grid\n\n        var proposedY = row + y;\n\n        if (proposedY < 0) {\n          continue;\n        } // Get the row on the grid\n\n\n        var possibleRow = grid[proposedY]; // Check row exists\n\n        if (possibleRow) {\n          // Check if this column in the row is undefined, if it's off the edges, 0, and empty\n          if (possibleRow[proposedX] === undefined || possibleRow[proposedX] !== 0) {\n            // undefined or not 0 and it's occupied we can't move here.\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/src/utils/index.js"],"names":["random","min","max","Math","floor","gridDefault","rows","cols","array","row","push","col","shapes","randomShape","length","defaultState","grid","shape","rotation","x","y","nextShape","isRunning","score","speed","gameOver","nextRotation","canMoveTo","currentShape","proposedX","proposedY","possibleRow","undefined"],"mappings":"AACA;AACA,OAAO,IAAMA,MAAM,GAAG,SAATA,MAAS,CAACC,GAAD,EAAMC,GAAN,EAAc;AAChC,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACH,MAAL,MAAiBE,GAAG,GAAGD,GAAN,GAAY,CAA7B,CAAX,IAA8CA,GAArD;AACH,CAFM,C,CAIP;;AACA,OAAO,IAAMI,WAAW,GAAG,SAAdA,WAAc,GAAM;AAC7B,MAAMC,IAAI,GAAG,EAAb;AACA,MAAMC,IAAI,GAAG,EAAb;AACA,MAAMC,KAAK,GAAG,EAAd,CAH6B,CAI7B;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,IAAxB,EAA8BG,GAAG,EAAjC,EAAqC;AACjCD,IAAAA,KAAK,CAACE,IAAN,CAAW,EAAX;;AACA,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGJ,IAAxB,EAA8BI,GAAG,EAAjC,EAAqC;AACnCH,MAAAA,KAAK,CAACC,GAAD,CAAL,CAAWC,IAAX,CAAgB,CAAhB;AACD;AACJ;;AACD,SAAOF,KAAP;AACH,CAZM,C,CAcP;;AACA,OAAO,IAAMI,MAAM,GAAG,CAClB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,CAFkB,EAOlB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,EAKC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CALD,CARkB,EAkBlB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,EAKC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CALD,EAUC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAVD,EAeC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAfD,CAnBkB,EAuClB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,EAKC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CALD,EAUC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAVD,EAeC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAfD,CAxCkB,EA4DlB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,EAKC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CALD,EAUC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAVD,EAeC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAfD,CA7DkB,EAiFlB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,EAKC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CALD,CAlFkB,EA4FlB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,EAKC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CALD,CA7FkB,EAuGlB;AACA,CAAC,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EACC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CADD,EAEC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAFD,EAGC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAHD,CAAD,CAxGkB,CAAf,C,CA8GP;AACA;;AACA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,GAAM;AAC7B,SAAOb,MAAM,CAAC,CAAD,EAAIY,MAAM,CAACE,MAAP,GAAgB,CAApB,CAAb;AACH,CAFM,C,CAIP;;AACA,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAe,GAAM;AAC9B,SAAO;AACL;AACAC,IAAAA,IAAI,EAAEX,WAAW,EAFZ;AAGL;AACAY,IAAAA,KAAK,EAAEJ,WAAW,EAJb;AAKL;AACAK,IAAAA,QAAQ,EAAE,CANL;AAOL;AACAC,IAAAA,CAAC,EAAE,CARE;AASLC,IAAAA,CAAC,EAAE,CAAC,CATC;AAUL;AACAC,IAAAA,SAAS,EAAER,WAAW,EAXjB;AAYL;AACAS,IAAAA,SAAS,EAAE,IAbN;AAcL;AACAC,IAAAA,KAAK,EAAE,CAfF;AAgBL;AACAC,IAAAA,KAAK,EAAE,IAjBF;AAkBL;AACAC,IAAAA,QAAQ,EAAE;AAnBL,GAAP;AAqBH,CAtBM,C,CAwBP;AACA;;AACA,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACT,KAAD,EAAQC,QAAR,EAAqB;AAC/C,SAAO,CAACA,QAAQ,GAAG,CAAZ,IAAiBN,MAAM,CAACK,KAAD,CAAN,CAAcH,MAAtC;AACD,CAFM;AAIP,OAAO,IAAMa,SAAS,GAAG,SAAZA,SAAY,CAACV,KAAD,EAAQD,IAAR,EAAcG,CAAd,EAAiBC,CAAjB,EAAoBF,QAApB,EAAiC;AACxD,MAAMU,YAAY,GAAGhB,MAAM,CAACK,KAAD,CAAN,CAAcC,QAAd,CAArB,CADwD,CAExD;;AACA,OAAK,IAAIT,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGmB,YAAY,CAACd,MAArC,EAA6CL,GAAG,EAAhD,EAAoD;AAChD,SAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGiB,YAAY,CAACnB,GAAD,CAAZ,CAAkBK,MAA1C,EAAkDH,GAAG,EAArD,EAAyD;AACrD;AACA,UAAIiB,YAAY,CAACnB,GAAD,CAAZ,CAAkBE,GAAlB,MAA2B,CAA/B,EAAkC;AAC9B;AACA,YAAMkB,SAAS,GAAGlB,GAAG,GAAGQ,CAAxB,CAF8B,CAG9B;;AACA,YAAMW,SAAS,GAAGrB,GAAG,GAAGW,CAAxB;;AACA,YAAIU,SAAS,GAAG,CAAhB,EAAmB;AACf;AACH,SAP6B,CAQ9B;;;AACA,YAAMC,WAAW,GAAGf,IAAI,CAACc,SAAD,CAAxB,CAT8B,CAU9B;;AACA,YAAIC,WAAJ,EAAiB;AACb;AACA,cAAIA,WAAW,CAACF,SAAD,CAAX,KAA2BG,SAA3B,IAAwCD,WAAW,CAACF,SAAD,CAAX,KAA2B,CAAvE,EAA0E;AACtE;AACA,mBAAO,KAAP;AACH;AACJ,SAND,MAMO;AACH,iBAAO,KAAP;AACH;AACJ;AACJ;AACJ;;AACD,SAAO,IAAP;AACD,CA9BM","sourcesContent":["\n// get a random number between min and max\nexport const random = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\n// Returns the default grid\nexport const gridDefault = () => {\n    const rows = 18\n    const cols = 10\n    const array = []\n    // array of 18 arrays of 10 zeros\n    for (let row = 0; row < rows; row++) {\n        array.push([])\n        for (let col = 0; col < cols; col++) {\n          array[row].push(0)\n        }\n    }\n    return array\n}\n\n// Define block shapes and their rotations as arrays.\nexport const shapes = [\n    // none\n    [[[0,0,0,0],\n      [0,0,0,0],\n      [0,0,0,0],\n      [0,0,0,0]]],\n  \n    // I\n    [[[0,0,0,0],\n      [1,1,1,1],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,0,0],\n      [0,1,0,0],\n      [0,1,0,0]]],\n  \n    // T\n    [[[0,0,0,0],\n      [1,1,1,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [1,1,0,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [1,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,1,0],\n      [0,1,0,0],\n      [0,0,0,0]]],\n  \n    // L\n    [[[0,0,0,0],\n      [1,1,1,0],\n      [1,0,0,0],\n      [0,0,0,0]],\n  \n     [[1,1,0,0],\n      [0,1,0,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,0,1,0],\n      [1,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,0,0],\n      [0,1,1,0],\n      [0,0,0,0]]],\n  \n    // J\n    [[[1,0,0,0],\n      [1,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,1,0],\n      [0,1,0,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,0,0,0],\n      [1,1,1,0],\n      [0,0,1,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,0,0],\n      [1,1,0,0],\n      [0,0,0,0]]],\n  \n    // Z\n    [[[0,0,0,0],\n      [1,1,0,0],\n      [0,1,1,0],\n      [0,0,0,0]],\n  \n     [[0,0,1,0],\n      [0,1,1,0],\n      [0,1,0,0],\n      [0,0,0,0]]],\n  \n    // S\n    [[[0,0,0,0],\n      [0,1,1,0],\n      [1,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,1,0],\n      [0,0,1,0],\n      [0,0,0,0]]],\n  \n    // O\n    [[[0,1,1,0],\n      [0,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]]]\n  ]\n\n// Return the index of a random shape from 1 to the number of items in `shapes`\n// We don't want the first item, which is an empty shape\nexport const randomShape = () => {\n    return random(1, shapes.length - 1)\n}\n\n// Return the default state for the game\nexport const defaultState = () => {\n    return {\n      // Create an empty grid\n      grid: gridDefault(),\n      // Get a new random shape\n      shape: randomShape(),\n      // set rotation of the shape to 0\n      rotation: 0,\n      // set the 'x' position of the shape to 5 and y to -4, which puts the shape in the center of the grid, above the top\n      x: 5,\n      y: -4,\n      // set the index of the next shape to a new random shape\n      nextShape: randomShape(),\n      // Tell the game that it's currently running\n      isRunning: true,\n      // Set the score to 0\n      score: 0,\n      // Set the default speed\n      speed: 1000,\n      // Game isn't over yet\n      gameOver: false\n    }\n}\n\n// Returns the next rotation for a shape\n// rotation can't exceed the last index of the the rotations for the given shape.\nexport const nextRotation = (shape, rotation) => {\n  return (rotation + 1) % shapes[shape].length\n}\n\nexport const canMoveTo = (shape, grid, x, y, rotation) => {\n  const currentShape = shapes[shape][rotation]\n  // Loop through all rows and cols of the **shape**\n  for (let row = 0; row < currentShape.length; row++) {\n      for (let col = 0; col < currentShape[row].length; col++) {\n          // Look for a 1 here\n          if (currentShape[row][col] !== 0) {\n              // x offset on grid\n              const proposedX = col + x\n              // y offset on grid\n              const proposedY = row + y\n              if (proposedY < 0) {\n                  continue\n              }\n              // Get the row on the grid\n              const possibleRow = grid[proposedY]\n              // Check row exists\n              if (possibleRow) {\n                  // Check if this column in the row is undefined, if it's off the edges, 0, and empty\n                  if (possibleRow[proposedX] === undefined || possibleRow[proposedX] !== 0) {\n                      // undefined or not 0 and it's occupied we can't move here.\n                      return false\n                  }\n              } else {\n                  return false\n              }\n          }\n      }\n  }\n  return true\n}"]},"metadata":{},"sourceType":"module"}