{"ast":null,"code":"import _classCallCheck from \"/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/src/components/grid-board.js\";\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport GridSquare from './grid-square';\nimport { moveDown } from '../actions'; // Get Shapes from utils\n\nimport { shapes } from '../utils'; // Represents a 10 x 18 grid of grid squares\n\nvar GridBoard =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(GridBoard, _Component);\n\n  function GridBoard(props) {\n    var _this;\n\n    _classCallCheck(this, GridBoard);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GridBoard).call(this, props));\n    _this.lastUpdateTime = 0;\n    _this.progressTime = 0;\n    return _this;\n  } // generates an array of 18 rows, each containing 10 GridSquares.\n\n\n  _createClass(GridBoard, [{\n    key: \"makeGrid\",\n    value: function makeGrid() {\n      // collect properties mapped to props from state.\n      var _this$props = this.props,\n          grid = _this$props.grid,\n          shape = _this$props.shape,\n          rotation = _this$props.rotation,\n          x = _this$props.x,\n          y = _this$props.y; // get the block which is the current shape the player is controlling\n\n      var block = shapes[shape][rotation];\n      var blockColor = shape; // map rows\n\n      return grid.map(function (rowArray, row) {\n        // map columns\n        return rowArray.map(function (square, col) {\n          // Find the block x and y on the shape grid\n          // By subtracting the x and y from the col and the row we get the position of the upper left corner of the block array as if it was superimposed over the main grid\n          var blockX = col - x;\n          var blockY = row - y;\n          var color = square; // Map current falling block to grid.\n          // For any squares that fall on the grid we need to look at the block array and see if there is a 1 in this case we use the block color. \n\n          if (blockX >= 0 && blockX < block.length && blockY >= 0 && blockY < block.length) {\n            color = block[blockY][blockX] === 0 ? color : blockColor;\n          } // Generate a unique key for every block\n\n\n          var k = row * grid[0].length + col; // Generate a grid square\n\n          return React.createElement(GridSquare, {\n            key: k,\n            square: square,\n            color: color,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 43\n            },\n            __self: this\n          }, square);\n        });\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      window.requestAnimationFrame(this.update.bind(this));\n    } // Handle game updates\n\n  }, {\n    key: \"update\",\n    value: function update(time) {\n      // If the game is is running we want to request a callback at the next animation frame.\n      window.requestAnimationFrame(this.update.bind(this));\n\n      if (!this.props.isRunning) {\n        return;\n      } // If lastUpdateTime not been set, set it to the current time.\n\n\n      if (!this.lastUpdateTime) {\n        this.lastUpdateTime = time;\n      } // Calculate delta time and progress time\n\n\n      var deltaTime = time - this.lastUpdateTime;\n      this.progressTime += deltaTime; // If the progress time is greater than speed move the block down\n\n      if (this.progressTime > this.props.speed) {\n        this.props.moveDown();\n        this.progressTime = 0;\n      } // set the last update time.\n\n\n      this.lastUpdateTime = time;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        className: \"grid-board\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 85\n        },\n        __self: this\n      }, this.makeGrid());\n    }\n  }]);\n\n  return GridBoard;\n}(Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    grid: state.game.grid,\n    shape: state.game.shape,\n    rotation: state.game.rotation,\n    x: state.game.x,\n    y: state.game.y,\n    speed: state.game.speed,\n    isRunning: state.game.isRunning\n  };\n}; // Map Dipatch to Props\n\n\nvar mapDispatchToProps = function mapDispatchToProps() {\n  return {\n    moveDown: moveDown\n  };\n}; // Connect the component\n\n\nexport default connect(mapStateToProps, mapDispatchToProps())(GridBoard);","map":{"version":3,"sources":["/Users/anisha/OneDrive - Art Academy University/MakeSchool/few2-4/tetris/src/components/grid-board.js"],"names":["React","Component","connect","GridSquare","moveDown","shapes","GridBoard","props","lastUpdateTime","progressTime","grid","shape","rotation","x","y","block","blockColor","map","rowArray","row","square","col","blockX","blockY","color","length","k","window","requestAnimationFrame","update","bind","time","isRunning","deltaTime","speed","makeGrid","mapStateToProps","state","game","mapDispatchToProps"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport GridSquare from './grid-square'\nimport { moveDown } from '../actions'\n// Get Shapes from utils\nimport { shapes } from '../utils'\n\n// Represents a 10 x 18 grid of grid squares\n\nclass GridBoard extends Component {\n    constructor(props) {\n      super(props)\n\n      this.lastUpdateTime = 0\n      this.progressTime = 0\n    }\n  \n    // generates an array of 18 rows, each containing 10 GridSquares.\n    makeGrid() {\n        // collect properties mapped to props from state.\n        const { grid, shape, rotation, x, y } = this.props\n        // get the block which is the current shape the player is controlling\n        const block = shapes[shape][rotation]\n        const blockColor = shape\n        // map rows\n        return grid.map((rowArray, row) => {\n          // map columns\n          return rowArray.map((square, col) => {\n            // Find the block x and y on the shape grid\n            // By subtracting the x and y from the col and the row we get the position of the upper left corner of the block array as if it was superimposed over the main grid\n            const blockX = col - x\n            const blockY = row - y\n            let color = square\n            // Map current falling block to grid.\n            // For any squares that fall on the grid we need to look at the block array and see if there is a 1 in this case we use the block color. \n            if (blockX >= 0 && blockX < block.length && blockY >= 0 && blockY < block.length) {\n              color = block[blockY][blockX] === 0 ? color : blockColor\n            }\n            // Generate a unique key for every block\n            const k = row * grid[0].length + col;\n            // Generate a grid square\n            return <GridSquare\n                    key={k}\n                    square={square}\n                    color={color}>{square}\n                  </GridSquare>\n          })\n        })\n    }\n\n    componentDidMount() {\n      window.requestAnimationFrame(this.update.bind(this))\n    }\n      \n    // Handle game updates\n    update(time) {\n      // If the game is is running we want to request a callback at the next animation frame.\n      window.requestAnimationFrame(this.update.bind(this))\n      if (!this.props.isRunning) {\n        return\n      }\n    \n      // If lastUpdateTime not been set, set it to the current time.\n      if (!this.lastUpdateTime) {\n        this.lastUpdateTime = time\n      }\n    \n      // Calculate delta time and progress time\n      const deltaTime = time - this.lastUpdateTime\n      this.progressTime += deltaTime\n    \n      // If the progress time is greater than speed move the block down\n      if (this.progressTime > this.props.speed) {\n        this.props.moveDown()\n        this.progressTime = 0\n      }\n    \n      // set the last update time.\n      this.lastUpdateTime = time\n    }\n\n    render () {\n        return (\n            <div className = 'grid-board'>\n                {this.makeGrid()}\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n      grid: state.game.grid,\n      shape: state.game.shape,\n      rotation: state.game.rotation,\n      x: state.game.x,\n      y: state.game.y,\n      speed: state.game.speed,\n      isRunning: state.game.isRunning\n    }\n}\n\n// Map Dipatch to Props\nconst mapDispatchToProps = () => {\n    return {\n      moveDown\n    }\n}\n\n// Connect the component\nexport default connect(mapStateToProps, mapDispatchToProps())(GridBoard)"]},"metadata":{},"sourceType":"module"}